#!/usr/bin/env python3
"""
Xero Watcher - Monitors Xero for new transactions
Syncs financial data with vault
"""

from pathlib import Path
from typing import List, Dict, Any
from datetime import datetime, timedelta
import sys
import json

sys.path.insert(0, str(Path(__file__).parent))
from base_watcher import BaseWatcher

class XeroWatcher(BaseWatcher):
    """
    Monitors Xero accounting system for:
    - New invoices
    - Received payments
    - Expenses
    - Bank transactions

    For Gold tier, simulates Xero integration
    In production, would use actual Xero API
    """

    def __init__(self, vault_path: str, check_interval: int = 3600):
        """
        Initialize Xero watcher

        Args:
            vault_path: Path to Obsidian vault
            check_interval: Seconds between checks (3600 = hourly)
        """
        super().__init__(vault_path, check_interval)

        self.last_sync_file = self.vault_path / 'Logs' / 'xero_last_sync.json'
        self.financial_summary = self.vault_path / 'Briefings' / 'financial_summary.json'

        # Initialize tracking
        if not self.last_sync_file.exists():
            self._save_last_sync({
                'last_invoice': None,
                'last_payment': None,
                'last_expense': None,
                'synced_at': datetime.now().isoformat()
            })

        self.logger.info('Xero Watcher initialized')

    def _save_last_sync(self, data: dict):
        """Save last sync information"""
        self.last_sync_file.write_text(json.dumps(data, indent=2))

    def _load_last_sync(self) -> dict:
        """Load last sync information"""
        if self.last_sync_file.exists():
            return json.loads(self.last_sync_file.read_text())
        return {}

    def check_for_updates(self) -> List[Dict[str, Any]]:
        """
        Check Xero for new transactions

        For Gold tier: Simulates Xero data
        For production: Would call actual Xero API

        Returns:
            List of new financial transactions
        """
        updates = []

        try:
            # Simulate checking Xero (in production, this would be API call)
            # For demo purposes, we'll create sample data periodically

            last_sync = self._load_last_sync()
            now = datetime.now()

            # Check if it's Monday (weekly financial summary)
            if now.weekday() == 0:  # Monday
                last_summary = last_sync.get('last_weekly_summary')

                if not last_summary or (now - datetime.fromisoformat(last_summary)).days >= 7:
                    # Generate weekly summary request
                    updates.append({
                        'type': 'weekly_financial_summary',
                        'period': f"{(now - timedelta(days=7)).strftime('%Y-%m-%d')} to {now.strftime('%Y-%m-%d')}",
                        'requested_at': now.isoformat()
                    })

                    last_sync['last_weekly_summary'] = now.isoformat()
                    self._save_last_sync(last_sync)

            # Simulate new invoice (for demo)
            # In production, this would check Xero API for actual new invoices

            self.logger.info(f'Xero check complete. Found {len(updates)} update(s)')

        except Exception as e:
            self.logger.error(f'Error checking Xero: {e}')

        return updates

    def create_action_file(self, item: Dict[str, Any]) -> Path:
        """
        Create action file for Xero transaction

        Args:
            item: Transaction information

        Returns:
            Path to created action file
        """
        unique_id = self._generate_unique_id()
        item_type = item.get('type', 'xero')

        action_filename = f'XERO_{unique_id}_{item_type}.md'
        action_path = self.needs_action / action_filename

        if item['type'] == 'weekly_financial_summary':
            content = f"""---
type: xero_weekly_summary
period: {item['period']}
status: pending
priority: high
created: {item['requested_at']}
---

# Weekly Financial Summary Request

## Period
{item['period']}

## Required Data from Xero

### Revenue
- Total invoices issued
- Total payments received
- Outstanding invoices
- Revenue breakdown by client

### Expenses
- Total expenses
- Expense breakdown by category
- Pending expense approvals

### Cash Flow
- Opening balance
- Closing balance
- Net change
- Projected next week

## Instructions for AI

1. Use [[Skills/xero_accountant]] skill
2. Generate comprehensive financial report
3. Identify any issues or concerns
4. Calculate key metrics:
   - Profit margin
   - Cash runway
   - Revenue growth %
5. Create CEO briefing in [[Briefings]] folder

## Integration Note
This will be part of the Monday CEO Briefing

---
*Auto-generated by XeroWatcher*
*For production use, connect actual Xero API*
"""
        else:
            content = f"""---
type: xero_transaction
transaction_type: {item.get('transaction_type', 'unknown')}
status: pending
priority: medium
created: {datetime.now().isoformat()}
---

# Xero Transaction

**Type:** {item.get('type', 'Unknown')}
**Details:** {json.dumps(item, indent=2)}

## Action Required
Process this Xero transaction using [[Skills/xero_accountant]]

---
*Auto-generated by XeroWatcher*
"""

        action_path.write_text(content, encoding='utf-8')
        self.logger.info(f'Created Xero action file: {action_filename}')

        return action_path

# Standalone execution
if __name__ == '__main__':
    import sys

    if len(sys.argv) < 2:
        print('Usage: python xero_watcher.py <vault_path> [check_interval]')
        print('Example: python xero_watcher.py ../AI_Employee_Vault 3600')
        sys.exit(1)

    vault_path = sys.argv[1]
    check_interval = int(sys.argv[2]) if len(sys.argv) > 2 else 3600

    watcher = XeroWatcher(vault_path, check_interval)

    print(f'\n{"="*60}')
    print(f'[*] Xero Watcher Started')
    print(f'{"="*60}')
    print(f'Vault: {vault_path}')
    print(f'Check Interval: {check_interval}s ({check_interval//3600}h)')
    print(f'{"="*60}\n')
    print('Monitoring Xero for financial transactions...')
    print('Press Ctrl+C to stop\n')

    try:
        watcher.run()
    except KeyboardInterrupt:
        print('\n\n[*] Watcher stopped by user')